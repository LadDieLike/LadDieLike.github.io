<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>(题解)[AtCoder Beginner Contest 393] D - Swap to Gather</title>
      <link href="/2025/02/19/%5B%E9%A2%98%E8%A7%A3%5D%5BAtCoder%20Beginner%20Contest%20393%5D%20D%20-%20Swap%20to%20Gather/"/>
      <url>/2025/02/19/%5B%E9%A2%98%E8%A7%A3%5D%5BAtCoder%20Beginner%20Contest%20393%5D%20D%20-%20Swap%20to%20Gather/</url>
      
        <content type="html"><![CDATA[<p>原题链接: <a href="https://atcoder.jp/contests/abc393/tasks/abc393_d">原题面</a></p><span id="more"></span><h3 id="问题陈述"><a href="#问题陈述" class="headerlink" title="问题陈述"></a>问题陈述</h3><p>你得到一个长度为 N 的字符串 S ，由 0 和 1 组成。保证 S 至少包含一个 1 。<br>您可以执行以下操作任意次数（可能为零）：<br><strong>· 选择一个整数 i （ 1≤i≤N−1 ）并交换 S 的第 i 个和第 (i+1) 个字符。</strong><br>找出使所有 1 连续所需的最小操作数。<br>这里，所有的 1 被称为是连续的，当且仅当存在整数 l 和 r （ 1≤l≤r≤N ），使得 S 的第 l~r之间都是1</p><h3 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h3><p>2≤N≤5×10^5<br>N 是整数。S 是一个长度为<br>N 的字符串，由 0 和 1 组成。<br>S 至少包含一个 1 。</p><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p>我们来解读一下题意，题目说要把所有的1放在一起，且只能通过交换相邻两个数的方式移动<br>那么我们假设有一个1要从 i 的位置移动到 j ，毫无疑问，移动次数是 j - i (j ≥ i)，也就是<strong>i 和 j 之间的距离</strong><br>此时一切都变得熟悉，距离，最短移动次数，连续，还记得七年级上册学的，求 |x+1|+|x+2| 这个不等式为最小值时，x的值是多少吗？没错，这道题就是它<strong>几何</strong>解法的变种（虽然我在第一次想的时候也没想出来哈哈哈）<br>事实上，这是一个经典的<strong>仓库选址问题</strong>，其最小值的x一定是在中间的(不懂请看：<a href="https://blog.csdn.net/weixin_52797843/article/details/122069259">货仓选址</a>)<br>但唯一有一点不一样的是，求那个不等式时算的是所有点到x这个点的距离，但本题要求的是所有的1都连续，那么怎么表示这个答案呢？<br>我们假设<strong>x的值是中间的那个1的位置</strong>，那么x左边的第一个1(假设位置为k)需要移动的距离就是x-k-1（只需要移动到相邻的那个位置），x左边第二个1(假设位置为q)需要移动的距离就是x-q-2，见图</p><p><img src="/%5B%E9%A2%98%E8%A7%A3%5D%5BAtCoder%20Beginner%20Contest%20393%5D%20D%20-%20Swap%20to%20Gather/1.png" alt="在这里插入图片描述"><br>我们发现，对于每一个1，它到最终“仓库”的距离是</p><blockquote><p>x-k+<strong>它距离仓库有多少个其他的1</strong></p></blockquote><p>因为每有一个1移动了，下一个1的移动距离就需要<strong>减一个距离单位</strong>(靠在已移动好的那个1旁边)<br>又由于这个字符串只由0或1组成，换句话说，这个字符串要么是0，要么是1<br><strong>如果k到x的距离会因为其中的1而减少，那么统计0的个数就可以了</strong><br>例如，k到x之间有两个0，所以它最少需要移动两步<br>q到x之间有三个0，所以它最少需要移动三步<br>知道了这一点之后，问题就变成了如何确定k与x之间0的个数<br>还是非常简单，类似于初中的线段和差<br>我们记录一下从<strong>0 ~ k中0的个数</strong>，再记录<strong>0 ~ x 中 0 的个数</strong>，两个相减，就得到了<strong>k ~ x中0的个数</strong><br>上代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">ll n,one[1000001];//&quot;1&quot; 的位置 </span><br><span class="line">ll cnt; //0~k-1中1的个数 </span><br><span class="line">ll x;//仓库的位置 </span><br><span class="line">ll ans;</span><br><span class="line">string a;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;a;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[i]==&#x27;1&#x27;) one[cnt+1]=i-cnt,cnt++;</span><br><span class="line">&#125;</span><br><span class="line">x=one[(cnt+1)/2];//仓库选址，取中位数，1一定是优于0的，所以在1的位置中选中位数 </span><br><span class="line">for(int i=1;i&lt;=cnt;i++) ans+=abs(one[i]-x);//算k~x 中0的个数，因为x是中位数，一定存在比它大的1的位置，故需要取绝对值 </span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以为什么我在比赛的时候想不出来。。。</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kruskal（克鲁斯卡尔）算法原理及图解案例</title>
      <link href="/2025/02/16/kruskal%EF%BC%88%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%EF%BC%89%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%9B%BE%E8%A7%A3%E6%A1%88%E4%BE%8B/"/>
      <url>/2025/02/16/kruskal%EF%BC%88%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%EF%BC%89%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%9B%BE%E8%A7%A3%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p>kruskal算法！</p><span id="more"></span><p>前置知识：并查集、图的存储<br>参考文献：<a href="https://oi-wiki.org/graph/mst/">OI Wiki</a></p><h3 id="什么是kruskal？"><a href="#什么是kruskal？" class="headerlink" title="什么是kruskal？"></a>什么是kruskal？</h3><p>kruskal是一种最小生成树算法，由Joseph Kruskal在1956年发表<br><strong>最小生成树</strong>（Minimum Spanning Tree，MST）简单来说就是：在一个<strong>连通图</strong>中，找出其中的一个<strong>可以使各个点之间连通</strong>且<strong>路权之和最小</strong>的连接方法，然后根据这个连接方法生成一个树<br>它的实现过程如下：</p><h3 id="算法原理（建议搭配下面的案例一起食用-）"><a href="#算法原理（建议搭配下面的案例一起食用-）" class="headerlink" title="算法原理（建议搭配下面的案例一起食用~~）"></a>算法原理（建议搭配下面的案例一起食用~~）</h3><p>我们将每一个点都看作一个<strong>无根树</strong>（独立的集合），并把这个图上的边全部存储下来，然后<strong>把所有边删掉</strong><br>然后将每一条<strong>边</strong>按权值大小<strong>从小到大</strong>排序</p><p>然后遍历每一条存储下来的边，用<strong>并查集</strong>判断<strong>这条边所连接的两个点是否在同一个集合內（查询是否连通）</strong>，若在，那么就不用添加这条边到最小生成树里去；若不在，这条边<strong>一定</strong>是最小生成树的一部分</p><p>相信没学过的你看到这一句话一定一脸懵，为什么这条边<strong>一定</strong>是最小生成树的一部分呢？</p><p>我们用到了贪心的策略<br>首先，若这两个点连通，那么<strong>先前的连接方案</strong>的权值一定是<strong>小于或等同于</strong>使用这条边连接的，因为假设当前边的权值<strong>小于</strong>先前的连接方案，那么它在排序的时候就到前面去了。故在两个点已经连通的情况下，不能也不需要加入这条边</p><p>若这两个点不连通，那么使用当前边连接这两个点一定是权值最小的，道理很简单，因为边是按照<strong>边是按照权值从大到小排序</strong>的，往后遍历的权值一定大于等于当前边，又因为你要一个最小生成树，所以每两个点之间迟早要连通，所以就赶紧趁着这个最优情况把这两个点连了，故这条边一定是最小生成树的一部分</p><p>以上两种情况可以互相印证，如第一种情况其实就可以看作是<strong>先前连接方案</strong>的第二种情况</p><p>所以当我们把所有边遍历完之后，最小生成树也就出来了</p><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p>首先我们拿到一个图<br><img src="/kruskal%EF%BC%88%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%EF%BC%89%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%9B%BE%E8%A7%A3%E6%A1%88%E4%BE%8B/graph.png" alt="图"></p><p>然后将这个图的每一条边排序得到<br><img src="/kruskal%EF%BC%88%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%EF%BC%89%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%9B%BE%E8%A7%A3%E6%A1%88%E4%BE%8B/edge.png" alt="边"></p><p>我们看第一条边，发现2和5不连通，那么我们就把它连接上<br><img src="/kruskal%EF%BC%88%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%EF%BC%89%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%9B%BE%E8%A7%A3%E6%A1%88%E4%BE%8B/graph1.png" alt="step1"></p><p>然后第二条边，发现3和5也不连通，那么就也把它连接上<br><img src="/kruskal%EF%BC%88%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%EF%BC%89%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%9B%BE%E8%A7%A3%E6%A1%88%E4%BE%8B/graph2.png" alt="step2"></p><p>然后第三条边，发现1和3也不连通，那么把它连接上<br><img src="/kruskal%EF%BC%88%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%EF%BC%89%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%9B%BE%E8%A7%A3%E6%A1%88%E4%BE%8B/graph3.png" alt="step3"></p><p>到第四条边的时候，发现1和5是连通的，故跳过<br>第五条边3和4不连通，故连接上<br><img src="/kruskal%EF%BC%88%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%EF%BC%89%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%9B%BE%E8%A7%A3%E6%A1%88%E4%BE%8B/graph4.png" alt="step5"></p><p>第六条边2和6不连通，故连接上<br><img src="/kruskal%EF%BC%88%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%EF%BC%89%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%9B%BE%E8%A7%A3%E6%A1%88%E4%BE%8B/graph5.png" alt="最小生成树"></p><p>第七条边1和6连通，故跳过<br>非常简单是不是？（我刚开始的时候不这么觉得<br>然后我们就得到了一个最小生成树<br>附上一个<strong>输出最小生成树的权值和</strong>的C++代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=5010;</span><br><span class="line">const int M=2e5+10;</span><br><span class="line">int n,m,ans;</span><br><span class="line">int fa[N],h[N];</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">int u,v,w;</span><br><span class="line">&#125;e[M];</span><br><span class="line"></span><br><span class="line">bool cmp(node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">return a.w&lt;b.w;</span><br><span class="line">&#125;</span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">if(x!=fa[x]) fa[x]=find(fa[x]);</span><br><span class="line">return fa[x];</span><br><span class="line">&#125;</span><br><span class="line">void merge(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">if(h[y]&gt;h[x]) fa[x]=fa[y];</span><br><span class="line">else if(h[x]&gt;h[y]) fa[y]=fa[x];</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">fa[y]=fa[x];</span><br><span class="line">h[x]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void kruskal()</span><br><span class="line">&#123;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">fa[i]=i;</span><br><span class="line">&#125;</span><br><span class="line">int cnt=0;</span><br><span class="line">for(int i=1;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">int u=e[i].u,v=e[i].v;</span><br><span class="line">int fx=find(u),fy=find(v);</span><br><span class="line">if(fx==fy) continue ;</span><br><span class="line">merge(fx,fy);</span><br><span class="line">ans+=e[i].w;</span><br><span class="line">//cout&lt;&lt;e[i].w&lt;&lt;endl;</span><br><span class="line">        cnt++;</span><br><span class="line">if(cnt==n-1) break;</span><br><span class="line">&#125;</span><br><span class="line">if(cnt!=n-1) cout&lt;&lt;&quot;orz&quot;;</span><br><span class="line">else cout&lt;&lt;ans; </span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">for(int i=1;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;e[i].u&gt;&gt;e[i].v&gt;&gt;e[i].w;</span><br><span class="line">&#125;</span><br><span class="line">sort(e+1,e+1+m,cmp);</span><br><span class="line">kruskal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有问题欢迎指出呀！~<br>共同进步AwA!</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024 CSP 游记</title>
      <link href="/2024/10/27/2024%20CSP%20%E6%B8%B8%E8%AE%B0/"/>
      <url>/2024/10/27/2024%20CSP%20%E6%B8%B8%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>这是我写的第一篇博客,同时也是我OI生涯的开端</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>暑假开始买了本信奥一本通，结果都没翻开来看，早知道就听 AMC 的不去买书了 www</p><h2 id="初赛"><a href="#初赛" class="headerlink" title="初赛"></a>初赛</h2><hr><p>J 组倒是没啥想说的，当时考完的时候还以为能 AK，结果错了几道判断，遗憾 93.5<br>当时还听说小六的 hwz 98，%%%</p><p>S 组也是给我蒙过去了，完善程序第一题考得刚好是我昨晚复习的二分，一看答案五<br>个 A，觉得肯定错了，但也懒得改，没想到答案还真是这样，最后 57.5 拿下</p><h2 id="复赛"><a href="#复赛" class="headerlink" title="复赛"></a>复赛</h2><hr><p>day 0 考前一天被班上同学全票选上班长（www…我要辞职）<br>结果晚上班级搞大扫除，六点开始的赛前集训我七点才到 后来也就是和其他 Oler 和 教练聊了会天，感觉状态非常好<br>后来就出发去考场旁边的酒店住了一晚（没睡好）</p><h2 id="day1-J"><a href="#day1-J" class="headerlink" title="day1-J"></a>day1-J</h2><hr><p>早上 7：00 起来昏沉沉的，当时就想这次肯定完蛋了，开考前也没太紧张(估计是没睡好所以才不觉得紧张)<br>然后就和其他 Oler 一起去考场等了</p><p>8：30 准时开考，由于是第一次考，一开始忘记了考试题是放在 D 盘里的，还纳闷怎么没有考<br>试文件，结果旁边的女选手也没意识到，还是个 i 人，愣是考了半小时她才说，好在我天资聪慧，想了 2 分钟终于想起来了</p><h3 id="看题"><a href="#看题" class="headerlink" title="看题"></a>看题</h3><hr><p>把四道题扫了一眼，初步判定前 A 题是水题，B 题搜索， C 题动规，D 题应该是个图</p><p>T1 poker</p><p>桶去重秒了，10mins 切了第一题，考完才想起来可以用 set</p><p>T2 explore</p><p>仔细看了题才发现这和搜索没关系，纯纯一送分模拟，20mins 切了</p><p>T3 sticks</p><p>题目让用 n 个火柴棒搭一个最小的数字，然后把每数字需要的火柴棒都给了你<br>读题的时候就觉得这几个特殊性质有意思，但还是没多想，在脑海中抽象了 10 几分钟，啥也没想到<br>没办法，先写了个深搜，突然发现 long long 放不下，直接改了 string（。。。）<br>再后来发现白改了，改了也 TLE，白费 10mins，再后来绞劲脑汁想优化没结果啥都没想到，无奈打表，把 n&lt;&#x3D;50 的情况全部打出来，发现答案好多 8，才意识到这就是个数学题，结合特殊性质的提示，<br>得出结论： 为了让数字最小，就得让数字位数最小，选择火柴棒根数最多的 8 来搭就能达到这一目的，然后就是相同余 数下的开头两位数不同，其他都是 8，最后为了保险，把 20 以内的数据都放在了数组里，这样就避免了特判， 考完就发现好多人没有注意到 n&#x3D;17 要特判，嘿嘿 写完这题的时候我那叫一个慌张，觉得这个答案未免太离谱，一堆 8，好在我心里素质强，坚信这是正解，花了 2 小时才切掉这题</p><p>T4 chain</p><p>看完 D 题果断放弃，这不是我可以写出来的（看题都看了半天，一开始看题都看错了，直接怀疑起样例解释）， 甚至爆搜都没有思路，回去检查罚坐了一小时</p><h3 id="最后估计：100-100-100-0-300"><a href="#最后估计：100-100-100-0-300" class="headerlink" title="最后估计：100+100+100+0&#x3D;300"></a>最后估计：100+100+100+0&#x3D;300</h3><hr><p>问了一下大家感觉 300 也就是个大众分，不过第一次考我已经很满意了，争取明年 AK！</p><h2 id="day1-S"><a href="#day1-S" class="headerlink" title="day1-S"></a>day1-S</h2><hr><h3 id="考前"><a href="#考前" class="headerlink" title="考前"></a>考前</h3><p>考完 J 组吃完午饭都接近两点了，午觉是一点没睡成，加上晚上没睡好，我还开玩笑和同学说去 S 赛场睡两小时</p><h2 id="看题-1"><a href="#看题-1" class="headerlink" title="看题"></a>看题</h2><hr><p>扫了一眼，觉得 A 题是个背包，B 题模拟+高中物理（加速度），C 题动规，D 题不想看，一看就写不出来（考完 去洛谷看了眼，黑题，好险没浪费时间）<br>T1 duel</p><p>一开始以为是个 01 背包，抽象了一下发现不是，数据范围不大，我直接桶排，然后根据当前项比较上一项，由于此时 每只怪兽数值都是有序的，所以只有两种情况： 1、当前项数量小于上一项，那就直接把上一项替换成当前项，最小剩下总数目不变 2、当前项数量大于上一项，那就直接把剩余数量加上数量之差 20mins 切掉第一题</p><p>T2 detect</p><p>一开始想着 AC 他，花 20mins 写了个 O(nm)的代码，发现读入的数据不对，排了半天错误，结果发现是把 int 数组开成了 bool，在上面花了 60mins，我直接红温，转到 T3<br>过了一会发现 T3 也写不出来，想着回来偷点分<br>然后就看特殊性质，发现 B 和 C 的性质很好拿分 B 和 C 的特殊性质只需要在最后一个检查站判断是否超速就行了，如果没有车辆超速，那就可以把所有检查站撤除，否则就保留最后一个，用时 45mins<br>当时加速度为负数的时候想半天想不到解法，考完试一听见有人说二分就悟了，哎，事后诸葛亮</p><p>T3 color</p><p>看了题，果断选择用二进制表示颜色，暴力搜索，然后过了小样例，后来脑抽换了深搜想优化，结果啥都没优化出来，果断 放弃，用时 20mins</p><h3 id="最后估计：100-40-20-160"><a href="#最后估计：100-40-20-160" class="headerlink" title="最后估计：100+40+20&#x3D;160"></a>最后估计：100+40+20&#x3D;160</h3><hr><p>一起学的Oler好像也就是写出来了第一题多一点点，平均水平吧只能说，但是我已经算发挥的很好了 第一次参加 csp，对于这个成绩我已经很满意了，前途无限呀！</p>]]></content>
      
      
      <categories>
          
          <category> 闲谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
